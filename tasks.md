### 1\. HTTP

**HTTP (HyperText Transfer Protocol)** — это протокол прикладного уровня для передачи данных (изначально гипертекста) в вебе. Он работает по модели "запрос-ответ".

Основные **методы**: **GET** (получение ресурса), **POST** (создание ресурса/отправка данных), **PUT** (полное обновление/замена ресурса), **PATCH** (частичное обновление) и **DELETE** (удаление).

**Параметры** передаются либо в строке URL (query parameters, `?id=123`, обычно для GET), либо в теле (body) запроса (обычно для POST/PUT).

**Заголовки (Headers)** — это метаданные запроса или ответа. Они несут служебную информацию: тип контента (`Content-Type`), аутентификация (`Authorization`), кэширование (`Cache-Control`), куки (`Cookie`) и т.д.

**Особенность HTTP/2** — это **мультиплексирование**. Он позволяет отправлять множество запросов и ответов *одновременно* в рамках одного TCP-соединения, используя **HTTP-потоки** (двунаправленные потоки байтов внутри соединения). Это устраняет "блокировку начала очереди" (Head-of-line blocking) и ускоряет загрузку.

-----

### 2\. Web-сервера

**Web-серверы** нужны для приёма HTTP-запросов от клиентов (браузеров) и возврата им HTTP-ответов (например, HTML-страниц, JSON-данных или статических файлов). Базовые возможности: обработка соединений, маршрутизация запросов к обработчикам, раздача статики (CSS, JS, картинки), логирование.

**Apache** — гибкий, модульный сервер, часто используемый на виртуальных хостингах; его ключевая особенность — возможность конфигурации на уровне директорий через файлы `.htaccess`.

**Nginx** — высокопроизводительный, асинхронный, событийно-ориентированный сервер. Он отлично справляется с раздачей статики и часто используется как **обратный прокси (reverse proxy)** и балансировщик нагрузки.

Конфигурирование **Nginx** декларативно (описывает *что* должно быть), использует блоки `server` и `location`. В качестве прокси он использует директиву `proxy_pass http://backend_address;` для перенаправления запроса на другой сервер (например, Node.js-приложение).

-----

### 3\. JavaScript и ECMAScript

**ECMAScript (ES)** — это **спецификация** (стандарт), которая описывает, как должен работать язык. **JavaScript (JS)** — это **реализация** этого стандарта (например, движок V8 в Chrome/Node.js), которая также включает специфичные API (например, DOM в браузере).

Ключевые отличия **ES5** от **новых версий** (ES6/ES2015+):

1.  **Переменные:** Появились `let` и `const` с блочной областью видимости (вместо `var` с функциональной).
2.  **Функции:** Появились стрелочные функции (`=>`), которые не имеют своего `this`.
3.  **Объекты/Массивы:** Деструктуризация, spread/rest-операторы (`...`), новые методы массивов (`find`, `includes`).
4.  **Асинхронность:** Появились `Promise` (в ES6) и `async/await` (в ES2017).
5.  **Модули:** `import` / `export`.
6.  **Классы:** Синтаксический сахар (`class`) поверх прототипного наследования.

**Замыкание** — это способность функции "помнить" и иметь доступ к переменным из своей внешней (родительской) области видимости, даже после того, как родительская функция завершила выполнение.

**Строгий режим** (`'use strict';`) — это опциональный режим JS, который делает язык "строже": запрещает небезопасные практики (например, использование необъявленных переменных) и превращает "тихие" ошибки в явные.

-----

### 4\. Особенности ES6+

**Promise (Обещание)** — это объект, представляющий результат *будущего* завершения (успешного или неудачного) асинхронной операции. Позволяет избавиться от "ада колбэков".

**Генераторы** (`function*`) — это особые функции, выполнение которых можно *приостанавливать* (через `yield`) и возобновлять, возвращая последовательность значений.

**Map** — это коллекция "ключ-значение", где ключом может быть *любой* тип данных (включая объекты), в отличие от обычного объекта, где ключ — только строка или символ. **WeakMap** — то же, но хранит *слабые* ссылки на ключи (только объекты), не препятствуя сборке мусора.

**Прокси (Proxy)** — это объект, который "оборачивает" другой объект и позволяет *перехватывать* операции с ним (чтение, запись, удаление свойств), реализуя метапрограммирование.

**Async/await** — это синтаксический сахар над `Promise`. Он позволяет писать асинхронный код так, будто он синхронный, используя `await` для "ожидания" выполнения Promise внутри функции, помеченной как `async`.

-----

### 5\. NPM, Yarn, NVM, Deno

**NPM** и **Yarn** — это **менеджеры пакетов** для Node.js. Они нужны для управления зависимостями проекта (скачивание, установка, обновление), которые описаны в файле `package.json`.

Основные команды: `npm install` (или `yarn add`) для установки пакета, `npm init` (или `yarn init`) для создания `package.json`, `npm run <script>` (или `yarn <script>`) для запуска скриптов.

Стандартные пакеты: `express` (веб-сервер), `lodash` (утилиты), `react` (UI-библиотека).

**NVM (Node Version Manager)** — это утилита командной строки, которая позволяет устанавливать и *переключаться* между разными версиями Node.js на одной машине.

**Deno** — это альтернативная Node.js среда выполнения JS/TS от создателя Node.js. Отличается **безопасностью** (скриптам нужны явные разрешения на доступ к файлам/сети) и **встроенной поддержкой TypeScript** без дополнительной настройки.

-----

### 6\. Модули и Логирование

Модули поддерживаются и **в браузере** (современные браузеры понимают ES6-модули через `<script type="module">`), и **на сервере** (Node.js).

**CommonJS (CJS)** — старый стандарт Node.js. Модули синхронные, используют `require()` для импорта и `module.exports` для экспорта.
**ES6-модули (ESM)** — современный стандарт языка. Модули асинхронные, используют `import` и `export`, поддерживают статичный анализ (tree-shaking).

**debug** — это очень лёгкая библиотека для *отладочных* сообщений. Её вывод включается переменной окружения `DEBUG=app:*`.
**winston** — это мощная, конфигурируемая библиотека для *логирования* (журналирования) приложения. Она поддерживает уровни логов (info, error) и "транспорты" (вывод в консоль, файл, базу данных).

Способы логирования в Node.js: от простого `console.log()` / `console.error()` до использования `debug` для разработки и `winston` (или pino) для production.

-----

### 7\. HTML и DOM

**Структура HTML** — это иерархическое дерево тегов. Базовая структура: `<!DOCTYPE html>`, `<html>`, `<head>` (метаданные, стили, скрипты) и `<body>` (видимый контент).

**DOM (Document Object Model)** — это **API** для HTML (или XML) документа. Это древовидное, объектное представление HTML-документа в памяти. DOM нужен, чтобы JavaScript мог программно читать и изменять содержимое, структуру и стили страницы (например, `document.getElementById('...')`).

**Обработка событий** (клик, ввод) осуществляется назначением обработчиков, чаще всего через `element.addEventListener('click', (event) => { ... })`.

**Распространение событий** — это процесс, как событие "путешествует" по DOM. Он состоит из 3 фаз: 1) **Захват (Capturing)** — от `window` вниз к целевому элементу, 2) **Цель (Target)** — сам элемент, 3) **Всплытие (Bubbling)** — от цели вверх обратно к `window`.

**Отличие "узла" (Node) от "элемента" (Element):** **Узел (Node)** — это *любой* объект в DOM-дереве (текстовый узел, комментарий, элемент). **Элемент (Element)** — это *конкретный тип* узла, который представляет HTML-тег (например, `<p>`, `<div>`). У `Element` есть методы, которых нет у `Node` (например, `querySelector` или `classList`).

-----

### 8\. CSS Селекторы и Стили

**Селекторы** — это правила, по которым CSS выбирает элементы для стилизации. Бывают: по тегу (`p`), классу (`.my-class`), ID (`#my-id`), атрибуту (`[href]`), селекторы потомков (`div p`), дочерние (`div > p`).

**Псевдоклассы** (например, `:hover`, `:focus`, `:nth-child`) определяют *состояние* элемента. **Псевдоэлементы** (например, `::before`, `::after`, `::first-line`) стилизуют *часть* элемента.

Способы настройки стилей:

1.  **Внешние (External)** — `<link rel="stylesheet">` (предпочтительный).
2.  **Внутренние (Internal)** — тег `<style>` в `<head>`.
3.  **Инлайновые (Inline)** — атрибут `style="..."` на самом элементе.

**Приоритеты (Специфичность):** Определяют, какое правило победит. По возрастанию: селекторы тегов \< классы \< ID \< инлайновые стили. Правило с `!important` имеет наивысший приоритет. Управлять можно, делая селектор более специфичным (например, `body #my-id` вместо `#my-id`).

**Динамическая вёрстка** (чаще **Адаптивная вёрстка** / Responsive Design) — это вёрстка, которая подстраивается под разные размеры экрана. Она выполняется с помощью **Медиа-запросов (Media Queries)** (`@media (max-width: 600px) { ... }`), которые применяют разные стили для разных ширин.

-----

### 9\. Grid и Flex

**CSS Grid** — это *двумерная* (2D) система вёрстки, позволяющая располагать элементы одновременно по строкам и колонкам. Она создаёт строгую сетку. Настраивается через `display: grid` на контейнере, а структура сетки определяется свойствами `grid-template-columns` и `grid-template-rows`.

**Flex-контейнер (Flexbox)** — это *одномерная* (1D) система вёрстки. Она позволяет располагать элементы либо в строку, либо в колонку. Flexbox идеален для выравнивания и распределения элементов вдоль одной оси. Настраивается через `display: flex` на контейнере. Свойства `flex-direction` (ось), `justify-content` (выравнивание по главной оси) и `align-items` (выравнивание по поперечной оси) управляют расположением.

-----

### 10\. LESS и SASS

**LESS** и **SASS** — это **CSS-препроцессоры**. Они нужны, чтобы упростить и структурировать написание CSS-кода. Они добавляют в CSS возможности, которых в нём нет (или не было):

1.  **Переменные** (для цветов, отступов).
2.  **Вложенность (Nesting)** селекторов.
3.  **Миксины (Mixins)** — переиспользуемые блоки стилей (как функции).
4.  **Наследование** (через `@extend`).

Их нотация (особенно SCSS, вариант SASS) похожа на CSS, но с этими дополнениями. Код на SASS/LESS **не** понимается браузером напрямую; он должен быть **скомпилирован** в обычный CSS-файл.

-----

### 11\. Шаблоны (Templating)

Шаблоны web-страниц можно создавать с помощью **шаблонизаторов** (template engines). На сервере (Node.js) популярны **Pug** (бывший Jade), **EJS** и **Handlebars**. Они позволяют вставлять данные (переменные, циклы) в HTML-разметку на стороне сервера.

В **Express** шаблонизатор подключается ( `app.set('view engine', 'pug')` ) и затем используется в роуте ( `res.render('templateName', { data })` ) для отправки готового HTML. **NestJS** (который часто использует Express) настраивается аналогично ( `app.setViewEngine('pug')` ) и может рендерить шаблоны в контроллерах.

-----

### 12\. Express

**Express** — это минималистичный, гибкий и популярный веб-фреймворк для Node.js. Его основные возможности — это **маршрутизация** и **Middleware**.

**Маршрутизация** (роутинг) делается через методы объекта `app` (или `Router`), которые соответствуют HTTP-методам: `app.get('/users', (req, res) => { ... })`, `app.post('/users', ...)`.

**Middleware** — это функции, которые имеют доступ к объектам запроса (`req`), ответа (`res`) и следующей функции middleware (`next`). Они выполняются "по цепочке" до основного обработчика роута.

Middleware бывает:

1.  **Встроенное** ( `express.json()` для парсинга JSON-тела, `express.static()` для раздачи статики).
2.  **Стороннее** ( `cors()`, `morgan()` ).
3.  **Кастомное** (самописное, например, для аутентификации).

**Обработка ошибок** в Express осуществляется через специальное middleware с 4 аргументами: `(err, req, res, next)`. Оно вызывается, если в любом предыдущем middleware была вызвана функция `next(err)`.

-----

### 13\. NestJS

**NestJS** — это прогрессивный Node.js-фреймворк для создания эффективных и масштабируемых серверных приложений. Он работает на **TypeScript** (хотя может и на JS).

Базовая архитектура NestJS (сильно вдохновлена Angular) состоит из трёх основных элементов:

1.  **Модули (Modules)** — инкапсулируют логику ( `AppModule` ).
2.  **Контроллеры (Controllers)** — отвечают за обработку входящих запросов и маршрутизацию.
3.  **Сервисы (Services/Providers)** — инкапсулируют бизнес-логику, подключаются через Dependency Injection (DI).

**Декораторы** в NestJS ( `@Controller`, `@Get`, `@Module`, `@Injectable` ) — это функции, которые добавляют метаданные к классам, методам или свойствам. Они используются NestJS для понимания структуры приложения (что есть контроллер, что сервис, какой роут).

-----

### 14\. REST и AJAX

**REST (Representational State Transfer)** — это *архитектурный стиль* для построения веб-сервисов.

**Требования к REST:**

1.  Клиент-серверная архитектура.
2.  **Stateless** (сервер не хранит состояние клиента между запросами).
3.  Кэшируемость ответов.
4.  Единый интерфейс (использование HTTP-методов по назначению, использование URI для ресурсов).

В REST используются HTTP-методы: **GET** (получение), **POST** (создание), **PUT** (обновление/замена), **DELETE** (удаление).

**AJAX (Asynchronous JavaScript and XML)** — это технология, позволяющая JavaScript отправлять HTTP-запросы к серверу *асинхронно* (в фоне), не перезагружая всю страницу. (Сейчас вместо XML почти всегда используется JSON). AJAX используется для создания "живых", динамических интерфейсов (SPA).

**Отличие POST и GET:** **GET**-запросы предназначены для *получения* данных, параметры передаются в URL, они кэшируются. **POST**-запросы — для *отправки* данных (создания/изменения), параметры передаются в теле (body) запроса, они не кэшируются.

-----

### 15\. Макет на Bootstrap Grid

Для реализации этого макета я использую контейнер, строку и классы сетки Bootstrap 5:

```html
<div class="container">
  <div class="row">
    <div class="col-lg-4 col-md-6 col-12">Блок 1</div>
    <div class="col-lg-4 col-md-6 col-12">Блок 2</div>
    <div class="col-lg-4 col-md-12 col-12">Блок 3</div>
  </div>
</div>
```

**Объяснение:**

  * На **больших** экранах (`col-lg-4`) все три блока займут по 4 из 12 колонок (т.е. 1/3).
  * На **средних** экранах (`col-md-*`) первые два блока (`col-md-6`) займут по 6 колонок (т.е. 1/2) и встанут в одну строку. Третий блок (`col-md-12`) займёт 12 колонок (всю ширину) и перенесётся на вторую строку.
  * На **маленьких** экранах (`col-12`) все блоки займут по 12 колонок (всю ширину) и выстроятся друг под другом.

-----

### 16\. Модальное окно Bootstrap

**Кнопка для открытия:**
Кнопка должна иметь два обязательных `data-bs-*` атрибута: `data-bs-toggle="modal"` (указывает, что это переключатель модального окна) и `data-bs-target="#myModal"` (CSS-селектор, указывающий ID модального окна).

`  <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#myModal"> `
`   Открыть окно `
`</button>`

**HTML-структура окна:**
Окно состоит из обёртки (`.modal`), диалога (`.modal-dialog`) и контента (`.modal-content`).

```html
<div class="modal fade" id="myModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Заголовок окна</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Дополнительная информация...</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
      </div>
    </div>
  </div>
</div>
```

**Закрытие окна:**
Чтобы окно закрывалось, любая кнопка (крестик `btn-close` или кнопка в футере) должна иметь атрибут `data-bs-dismiss="modal"`. Закрытие при клике на область вне окна (backdrop) включено по умолчанию.

-----

### 17\. TypeScript vs JavaScript

Ключевое отличие: **TypeScript (TS)** — это **статически типизированный** язык (типы проверяются на этапе компиляции). **JavaScript (JS)** — **динамически типизированный** (типы проверяются во время выполнения). TS является "надмножеством" (superset) JS и компилируется в обычный JS.

Новые типы в TS: `any`, `unknown` (типобезопасный `any`), `void` (функция ничего не возвращает), `never` (функция никогда не завершается), `tuple` (кортеж — массив с фиксированным набором типов), `enum` (перечисление).

Варианты объединения:

1.  **Union Types (Объединение)**: `string | number`. Переменная может быть *или* строкой, *или* числом.
2.  **Intersection Types (Пересечение)**: `TypeA & TypeB`. Объект должен иметь *все* свойства и `TypeA`, и `TypeB`.

**Атрибуты (свойства) и методы классов** в TS могут иметь модификаторы доступа: `public` (по умолчанию), `private` (доступен только внутри класса), `protected` (доступен внутри класса и у наследников). В JS приватность реализуется через синтаксис `#` (`#myPrivateField`).

-----

### 18\. Особенности TypeScript

**Перегрузка функций** реализуется объявлением нескольких *сигнатур* (определений) функции с разными типами, за которыми следует *одна* реализация, способная обработать все эти сигнатуры (часто с `any` или union-типами).

**"Защита" типа (Type Guard)** — это выражение, которое выполняет проверку типа и "сужает" его для TS в определённом блоке кода. Примеры: `typeof x === 'string'`, `x instanceof MyClass` или кастомные функции-предикаты ( `x is Type` ).

**Generics (Дженерики)** (`<T>`) — это способ создания переиспользуемых компонентов (функций, классов, интерфейсов), которые могут работать с *разными* типами, сохраняя при этом строгую типизацию (например, `Array<T>`).

**Пространство имён (namespace)** — это старый способ группировки связанного кода в TS, чтобы избежать конфликтов имён в глобальной области. Сейчас его почти полностью заменили ES6-модули.

**Декораторы** (`@myDecorator`) — это специальные функции, которые могут быть применены к классам, методам, свойствам или параметрам для изменения их поведения или добавления метаданных (широко используются в Angular и NestJS).

-----

### 19\. Flow

**Flow** — это **статический анализатор типов** для JavaScript, разработанный Facebook (альтернатива TypeScript).

Flow использует специальный синтаксис (аннотации типов), который не является валидным JS. **Babel** ему нужен, чтобы **удалить** эти аннотации типов из кода, превратив его в обычный JS для выполнения.

Flow не будет работать без инициализации (`flow init`, создаёт `.flowconfig`) и запуска проверки (`flow check`). Также файлы должны содержать комментарий `// @flow` (или `@flow strict`).

Flow, как и TS, не добавляет новые возможности *времени выполнения* в JS, он добавляет **статическую проверку типов** на этапе разработки, помогая находить ошибки до запуска кода.

-----

### 20\. Angular (Структура)

**Angular** состоит из **Модулей** (NgModules) и **Компонентов**.

  * **Компоненты** (`@Component`) — отвечают за UI (HTML-шаблон + логика).
  * **Модули** (`@NgModule`) — группируют связанные компоненты, директивы и сервисы.

**Минимальное приложение** — это один корневой модуль (`AppModule`), который "загружает" (`bootstrap`) один корневой компонент (`AppComponent`).

**Свойства @NgModule:**

  * `declarations`: Компоненты, директивы, пайпы, принадлежащие этому модулю.
  * `imports`: Другие модули, которые нужны этому модулю.
  * `providers`: Сервисы (Dependency Injection).
  * `bootstrap`: Корневой компонент (только для AppModule).

**Свойства @Component:**

  * `selector`: CSS-селектор тега ( `<app-root>` ).
  * `templateUrl`: Путь к HTML-файлу шаблона.
  * `styleUrls`: Массив путей к файлам стилей.

**Шаблон компонента** — это его HTML-разметка. Его можно описать инлайн (свойство `template: '<h1>Hi</h1>'`) или подключить из внешнего файла ( `templateUrl: './app.component.html'` ).

**Встроенные директивы:**

  * **Структурные** (меняют DOM): `*ngIf` (условие), `*ngFor` (цикл).
  * **Атрибутивные** (меняют вид/поведение): `[ngClass]`, `[ngStyle]`, `[(ngModel)]` (двустороннее связывание).

-----

### 21\. Angular (Функционал)

**Маршрутизация (Routing)** организуется через `RouterModule`. В корневом модуле используется `RouterModule.forRoot(routes)`, где `routes` — массив объектов ( `{ path: 'home', component: HomeComponent }` ). В HTML используется тег `<router-outlet>` для отображения компонента, соответствующего текущему URL.

**Параметры** при маршрутизации передаются в URL ( `/user/:id` ) и считываются в компоненте через сервис `ActivatedRoute`.

**Шаблонная переменная** (`#myVar`) — это ссылка на DOM-элемент или компонент внутри HTML-шаблона.

**К дочернему компоненту** можно обратиться из кода родителя, используя декоратор `@ViewChild()`.

**Валидация данных** реализуется через **Реактивные формы** (Reactive Forms, `FormBuilder`, `FormGroup`, `Validators`) или **Шаблонные формы** (Template-Driven Forms, `ngModel`).

**Сервисы** — это классы с декоратором `@Injectable()`, предназначенные для инкапсуляции бизнес-логики (например, HTTP-запросы).
**DI (Dependency Injection)** — это паттерн, который Angular использует для предоставления компонентам экземпляров сервисов (компонент просто запрашивает сервис в своём конструкторе).
**Иерархия сервисов** означает, что сервис может быть зарегистрирован на разных уровнях: в `root` (синглтон для всего приложения) или в модуле/компоненте (новый экземпляр).

-----

### 22\. Angular (Жизненный цикл и HTTP)

**Жизненный цикл компонента** Angular включает методы-хуки:

  * `ngOnChanges`: Вызывается при изменении `@Input()` свойств.
  * `ngOnInit`: Вызывается один раз после инициализации.
  * `ngDoCheck`: Вызывается при каждой проверке изменений.
  * `ngAfterViewInit`: Вызывается после инициализации дочерних view.
  * `ngOnDestroy`: Вызывается перед уничтожением компонента.

**Взаимодействие между компонентами:**

1.  **@Input()**: Передача данных от родителя *к* дочернему.
2.  **@Output()** (с `EventEmitter`): Передача события от дочернего *к* родителю.
3.  Через **общий сервис**.

**Директивы** бывают **структурные** ( `*ngIf`, `*ngFor` — меняют DOM) и **атрибутивные** ( `[ngClass]` — меняют свойства). **Да**, можно создать новые директивы ( `@Directive()` ).

**Взаимодействие с сервером** осуществляется через `HttpClientModule`. В сервисе используется `HttpClient` ( `http.get('/api/data')` ) для отправки HTTP-запросов. `HttpClient` возвращает `Observable` (из библиотеки RxJS).

-----

### 23\. React (Основы)

**Иммутабельность** — это принцип, при котором данные (особенно `state` и `props`) нельзя изменять (мутировать). Вместо этого нужно создавать *новую* копию данных с изменениями. React использует это для оптимизации (сравнивая ссылки, он решает, нужно ли делать ре-рендеринг).

**JSX** — это **синтаксическое расширение** JavaScript (JavaScript XML). Он позволяет писать HTML-подобный код (`<h1>Hi</h1>`) прямо в JS-файлах. JSX — это "сахар" для функции `React.createElement()`.

**React-элемент** — это легковесный, "виртуальный" объект, описывающий, *что* нужно отрендерить (тип, props). React использует эти элементы для построения Виртуального DOM.

**Варианты определения компонента:**

1.  **Функциональные компоненты** ( `function MyComponent(props) { ... }` ) — сейчас стандарт, используются с хуками.
2.  **Классовые компоненты** ( `class MyComponent extends React.Component { render() { ... } }` ) — старый подход, имеют state и методы жизненного цикла.

**Пропсы (props)** — это объект с данными, которые передаются *в* компонент от родителя (аналог аргументов функции). Они **неизменяемы (read-only)**.

`props.children` — это специальный prop, который содержит всё, что было передано *внутрь* тега компонента (например, `<MyComponent>Вот это children</MyComponent>`).

-----

### 24\. React (Жизненный цикл, Компоненты)

**Методы жизненного цикла** (в классовых компонентах):

  * `constructor()`: Инициализация, установка state.
  * `render()`: Возвращает JSX.
  * `componentDidMount()`: Вызывается после монтирования (для AJAX-запросов, подписок).
  * `componentDidUpdate()`: Вызывается после обновления.
  * `componentWillUnmount()`: Вызывается перед размонтированием (для очистки).

**Управляемые (Controlled)** компоненты (например, `<input>`) получают своё значение (`value`) из `state` React и обновляют `state` через `onChange`. React полностью "контролирует" инпут.
**Неуправляемые (Uncontrolled)** хранят своё значение в DOM (как обычный HTML), и React получает к нему доступ через **рефы (ref)**.

**Ключ (key)** — это обязательный `string` атрибут, который нужно указывать при рендеринге **списков** (массивов) элементов. Ключи помогают React идентифицировать, какие элементы изменились, добавились или удалились, что оптимизирует ре-рендеринг.

**Реф (ref)** — это "ссылка" на DOM-элемент или экземпляр классового компонента. Используется (через `useRef()` или `createRef()`) для прямого доступа к DOM (фокус, измерение).

**События React** ( `onClick` ) — это **синтетические события** (обёртки над нативными), которые работают одинаково во всех браузерах. Имена в `camelCase`.

**Условный рендеринг** — это рендеринг разного JSX в зависимости от условия. Используется `if`, тернарный оператор (`{condition ? <A /> : <B />}`) или `&&`. Чтобы "отключить" (не рендерить) компонент, нужно вернуть из него `null`.

-----

### 25\. React (Хуки, Роутинг, Состояние)

**Хуки (Hooks)** — это функции (начинаются с `use...`), которые позволяют использовать `state` и другие фичи React (как `useEffect`) в **функциональных компонентах**.

**useState** — это хук для добавления **локального состояния** в компонент. `const [count, setCount] = useState(0);`
**useEffect** — это хук для выполнения **побочных эффектов** (side effects): запросы данных (fetch), подписки, прямая работа с DOM. `useEffect(() => { ... }, [dependencies]);`

Хуки можно использовать **только на верхнем уровне** функциональных компонентов или внутри других кастомных хуков. Их **нельзя** вызывать в циклах, условиях или обычных JS-функциях.

**Маршрутизация** (роутинг) в React реализуется с помощью сторонних библиотек, чаще всего `react-router-dom` (компоненты `BrowserRouter`, `Route`, `Link`).

**Единое (глобальное) состояние** в приложении реализуется:

1.  **Context API** (`React.createContext`, `useContext`) — встроенный механизм для проброса данных "вниз" по дереву, минуя пропсы.
2.  **State Managers** (сторонние библиотеки) — **Redux** (стандарт), **Zustand**, **MobX**.

-----

### 26\. Vue (Основы)

Компонент Vue (в `.vue` файле, SFC - Single File Component) состоит из трёх частей:

1.  **`<template>`** (HTML-разметка).
2.  **`<script>`** (логика, JS/TS).
3.  **`<style>`** (стили).

Особенность стилей — атрибут **`scoped`** (`<style scoped>`), который делает CSS-правила локальными, применяя их только к элементам *этого* компонента.

**`v-bind`** (короткая запись **`:`**) — это **одностороннее** связывание. Он *связывает* данные из `<script>` с атрибутом HTML ( `v-bind:href="myUrl"` или `:href="myUrl"` ).
**`v-model`** — это **двустороннее** связывание. Используется с инпутами ( `<input v-model="message">` ). Он одновременно *связывает* `value` инпута с данными (`v-bind`) и *обновляет* данные при вводе (`v-on:input`).

**`v-on`** (короткая запись **`@`**) — это директива для **обработки событий** ( `v-on:click="myMethod"` или `@click="myMethod"` ).

-----

### 27\. Vue (Приложение, Хуки, Логика)

Приложение Vue (v3) создаётся через `createApp(RootComponent)` и монтируется к DOM-элементу через `.mount('#app')`.

**Хуки** жизненного цикла (в Options API): `created()` (компонент создан), `mounted()` (вставлен в DOM), `updated()` (обновлён), `unmounted()` (удалён). (В Composition API: `onMounted`, `onUnmounted` и т.д.).

**Интерполяция** — это вставка данных из логики в шаблон. В Vue используется синтаксис "усов": `{{ myVariable }}`.

**`data()`** (в Options API) — это *функция*, которая *возвращает* объект с локальным состоянием компонента. Это должна быть функция (а не объект), чтобы у каждого экземпляра компонента было своё, независимое состояние.

**methods** — это объект с *функциями*, которые выполняются **заново** при каждом вызове в шаблоне ( `{{ myMethod() }}` ).
**computed** (вычисляемые свойства) — это свойства, основанные на `data`. Они **кэшируются** и пересчитываются, только если их зависимости изменились. В шаблоне вызываются как свойства, без `()` ( `{{ myComputedProperty }}` ).

-----

### 28\. TDD и Chai

**TDD (Test-Driven Development)** — это методология разработки "через тестирование". Процесс следует циклу **"Red-Green-Refactor"**:

1.  **Red**: Пишется **тест** (который падает, т.к. кода ещё нет).
2.  **Green**: Пишется **минимальный код**, чтобы тест прошёл.
3.  **Refactor**: Код "причёсывается" (рефакторится) без изменения поведения.

**Chai** — это библиотека **утверждений (assertion library)** для тестов. Она предоставляет синтаксис для проверки результатов. Chai поддерживает три стиля:

1.  **Assert**: Классический TDD-стиль. `assert.equal(foo, 'bar', 'foo is not bar');`
2.  **Should**: BDD-стиль, расширяет `Object.prototype`. `foo.should.equal('bar');`
3.  **Expect**: BDD-стиль (самый популярный). `expect(foo).to.equal('bar');`

-----

### 29\. TDD и Фреймворки (Mocha, Jest)

**TDD (Test-Driven Development)** — это методология "Red-Green-Refactor": пишем тест, пишем код, делаем рефакторинг.

**Mocha** — это гибкий **фреймворк для запуска тестов** (test runner). Он *предоставляет структуру* для тестов (функции `describe()` для группировки и `it()` для тест-кейсов) и запускает их. Mocha *не включает* в себя библиотеку утверждений — её нужно подключать отдельно (например, Chai).

**Jest** — это **"всё-в-одном"** фреймворк для тестирования от Facebook. Он включает в себя *всё* необходимое: test runner (как Mocha), *встроенную* библиотеку утверждений ( `expect()` ) и инструменты для мокирования (mocks).

-----

### 30\. Selenium и Headless

**Selenium** — это набор инструментов для **автоматизации браузеров**. Он позволяет коду (Java, JS, Python) управлять браузером. Используется в основном для E2E (End-to-End) тестирования.

**Selenium IDE** — это плагин для браузера, который позволяет **записывать** и **воспроизводить** действия пользователя (клики, ввод) без написания кода. Он проще, чем Selenium WebDriver (API для кода).

Типовые команды IDE: `open` (URL), `click` (селектор), `type` (селектор, текст), `assertText` (проверка текста), `waitForElementVisible`. Элементы ищутся по ID, Name, CSS-селектору или XPath.

**Protractor** — это E2E-тест-фреймворк (обёртка над Selenium), созданный *специально для Angular*-приложений (сейчас устарел).

**Headless браузер** — это браузер **без графического интерфейса** (GUI). Он нужен для запуска тестов (Selenium/Protractor) на серверах (CI/CD), где нет монитора. Он работает быстрее и потребляет меньше ресурсов. Воспользоваться можно, передав флаг `--headless` при запуске браузера (например, в Chrome).

-----

### 31\. Gulp и Webpack

Ключевое отличие:

  * **Gulp** — это **таск-раннер** (task runner). Он автоматизирует *потоковые* задачи (streams): взять файлы, минифицировать, скомпилировать SASS, сложить в папку.
  * **Webpack** — это **сборщик модулей** (module bundler). Его главная задача — взять JS-модули (и другие ресурсы, как CSS/img), проанализировать `import`-ы и собрать их в один (или несколько) "бандл" для браузера.

**Задачи Gulp:** Минификация CSS/JS, компиляция SASS/LESS, оптимизация изображений, "склейка" (конкатенация) файлов.
Задача Gulp описывается в `gulpfile.js` как JS-функция, которая использует `gulp.src()` (взять файлы), `pipe()` (обработать) и `gulp.dest()` (положить результат).

Ограничение на имя файла — `gulpfile.js`. **Да**, в `gulpfile.js` можно использовать `import`, если в `package.json` указан `"type": "module"`, иначе используется `require()`.

-----

### 32\. Webpack

**Связь entry и output:** **Entry** (точка входа) — это главный JS-файл, с которого Webpack *начинает* строить граф зависимостей. **Output** (выход) — указывает, *куда* и *под каким именем* сохранить итоговый собранный "бандл".

По умолчанию `entry` — это `./src/index.js`. `output` (результат) — это `./dist/main.js`.

**Загрузчики (Loaders)** нужны, чтобы научить Webpack обрабатывать файлы, *не являющиеся* JavaScript (т.к. Webpack "понимает" только JS/JSON). Типы: `babel-loader` (ES6 -\> ES5), `css-loader` (CSS -\> JS), `sass-loader` (SASS -\> CSS), `file-loader` (картинки).

В массиве `use: ['css-loader', 'sass-loader']` загрузчики выполняются **справа налево** (или **снизу вверх**). Сначала `sass-loader` (SASS -\> CSS), потом `css-loader`.

Webpack поддерживает команды загрузки модулей ES6 (`import`/`export`), CommonJS (`require`) и AMD.

**devtool** — это опция для генерации **Source Maps** (карт исходного кода). Они нужны, чтобы в отладчике браузера видеть не скомпилированный бандл (`main.js`), а оригинальный исходный код, что упрощает отладку.

-----

### 33\. Web API (Workers, Sockets, Storage)

**Web Worker** — это API для запуска JS-скрипта в **фоновом потоке**, отдельно от основного потока UI. Используется для тяжёлых вычислений, чтобы не "вешать" интерфейс. **SharedWorker** — это Worker, к которому могут подключиться *несколько* разных вкладок (с одного origin).

**Web-сокет** создаётся через `const ws = new WebSocket('ws://server.com')`. Это *двусторонний* (full-duplex) протокол. Взаимодействие: `ws.send('data')` (отправка), `ws.onmessage = (event) => ...` (получение). **Да**, серверная часть WebSocket может быть написана на любом языке (Node.js, Python, Java).

**Да**, в истории (`history`) можно сохранить выполнение AJAX-запросов. Это делается с помощью **History API** (`history.pushState()` и `history.replaceState()`). Это позволяет менять URL в браузере *без перезагрузки* страницы (так работают SPA).

**sessionStorage / localStorage** — это Web Storage API (хранилища "ключ-значение" в браузере). Работа: `localStorage.setItem('key', 'value')`, `localStorage.getItem('key')`.
**Отличие:** **localStorage** — данные *постоянны*, хранятся "вечно" и доступны всем вкладкам *одного origin*. **sessionStorage** — данные хранятся только на время **одной сессии** (одной вкладки) и *удаляются* при закрытии вкладки.

-----

### 34\. PHP и JavaScript (Сравнение 1)

Код PHP, встроенный в HTML (`<?php echo $var; ?>` или `<?= $var ?>`), похож на "классические" шаблонизаторы, такие как EJS или ASP.

**Да**, на PHP-страницах можно использовать JavaScript.
**Исполнение:** **PHP** (`<?php ... ?>`) исполняется **на сервере** (до отправки страницы, генерирует HTML). **JavaScript** (`<script> ... </script>`) исполняется **на клиенте** (в браузере), *после* того как PHP отработал.

**Переменные:**

  * **Похожи:** Ключевые слова `if`, `else`, `while`, `function` (но функции в PHP не первого класса).
  * **Отличаются:** В PHP все переменные начинаются с `$` ( `$myVar` ). В JS для объявления используются `let`, `const`, `var`.

**Шаблоны строк:**

  * **Похожи:** Оба языка имеют интерполяцию.
  * **Отличаются:** JS использует обратные кавычки (backticks) `` `${myVar}` ``. PHP использует двойные кавычки `"My var is $myVar"` (интерполяция) или одинарные `'My var is $myVar'` (без интерполяции).

-----

### 35\. PHP и JavaScript (Сравнение 2)

**Переменная в PHP** объявляется присваиванием значения, всегда начинается с `$` ( `$myVar = 10;` ).
**Типы PHP:** Скалярные (`int`, `float`, `string`, `bool`), составные (`array`, `object`), специальные (`resource`, `null`).
**Константы:** Да, существуют (`define('MY_CONST', 10)` или `const MY_CONST = 10;`).

**Операторы:**

  * **Похожи:** Арифметические (`+`, `-`, `*`), присваивания (`=`), сравнения (`==`, `!=`), строгая идентичность (`===`).
  * **Отличаются:** В PHP оператор конкатенации строк — это точка (`.`), а в JS — плюс (`+`).

**Суперглобальные переменные PHP:** `$_GET` (данные из URL), `$_POST` (данные из body), `$_SESSION` (данные сессии), `$_COOKIE` (куки), `$_SERVER` (инфо о сервере/запросе).

**include vs require:** Оба вставляют содержимое другого файла.

  * `include` при ошибке (файл не найден) выдаст `Warning` и скрипт *продолжит* выполнение.
  * `require` выдаст `Fatal Error` и скрипт *остановится*.

**Работа с Cookie:**

  * **JS (клиент):** Чтение/запись идёт через `document.cookie` (ограничено).
  * **PHP (сервер):** Установка идёт функцией `setcookie()` (отправка заголовка `Set-Cookie`). Чтение — из суперглобального массива `$_COOKIE`.

-----

### 36\. Web-уязвимости

Основные уязвимости: **SQL-инъекции (SQLi)**, **XSS (Межсайтовый скриптинг)** и **CSRF (Межсайтовая подделка запроса)**.

**SQL-уязвимость (SQL-injection)** — это уязвимость, позволяющая злоумышленнику выполнить произвольный SQL-запрос к базе данных. Возникает, когда данные от пользователя (например, из `$_GET`) *напрямую* вставляются (конкатенируются) в SQL-запрос. Защита: **подготовленные выражения (prepared statements)**.

**XSS-уязвимость (Cross-Site Scripting)** — это внедрение вредоносного *клиентского* скрипта (JavaScript) на страницу, которую увидят другие пользователи. Возникает, когда данные от пользователя (комментарий, имя) выводятся на страницу *без экранирования* (HTML escaping).

**Если вы нашли уязвимость:**

1.  **Не эксплуатировать** её в злых целях.
2.  **Конфиденциально** сообщить о проблеме команде безопасности сервиса (через security-контакт, e-mail или Bug Bounty программу).
3.  **Не публиковать** информацию до тех пор, пока уязвимость не будет исправлена.

-----

### 37\. WebAssembly

**WebAssembly (WASM)** — это **бинарный формат инструкций** (низкоуровневый байт-код), который может выполняться в веб-браузерах.

**Как работает:** Код, написанный на языках C, C++, Rust, компилируется в `.wasm` файл. Браузер (через JS API) загружает этот файл и выполняет его в "песочнице" со скоростью, близкой к нативной. JS выступает как "клей" для вызова WASM-функций.

**Примеры использования:** Высокопроизводительные задачи в браузере: 3D-игры (Figma, Unity, Unreal Engine), редактирование видео/аудио, криптография, портирование "тяжёлых" десктопных приложений (AutoCAD).

-----

### 38\. REST vs SOAP (Банковская система)

а) Для сложной банковской системы я выберу **SOAP**.
**Аргументы:**

1.  **Контракт (WSDL):** SOAP использует **WSDL (Web Services Description Language)** — это строгий, машиночитаемый контракт, который описывает все операции, типы данных, входы и выходы. Для банковской сферы, где важна строгая типизация, это критично. REST (с OpenAPI/Swagger) тоже может иметь контракт, но он не так строг, как WSDL.
2.  **Стандарты:** SOAP — это *протокол* (REST — *стиль*) со встроенными стандартами: **WS-Security** (для шифрования и подписей на уровне сообщений), поддержка транзакций (ACID). В REST это пришлось бы реализовывать вручную поверх HTTP/SSL.
3.  **Надёжность:** SOAP часто используется поверх надёжных протоколов (не только HTTP) и имеет встроенные механизмы повторных попыток.

б) **Компоненты WSDL** для операции перевода средств:

  * **`<types>`**: Определение типов данных (используя XSD). Например, `AccountNumber` (string), `Amount` (decimal), `Currency` (enum).
  * **`<message>`**: Определение сообщений (запроса и ответа). Например, `TransferRequest` (включает `fromAccount`, `toAccount`, `amountDetails`) и `TransferResponse` (включает `status`, `transactionId`).
  * **`<portType>`**: Определение "операции". Например, операция `transferFunds`, которая принимает сообщение `TransferRequest` и возвращает `TransferResponse`.
  * **`<binding>`**: Привязка операции к конкретному протоколу (т.е. SOAP через HTTP).
  * **`<service>`**: Адрес (endpoint), где этот сервис физически доступен.

-----

### 39\. GraphQL и gRPC

а) **GraphQL и избыточность (Over-fetching):**
В REST, запрос `GET /api/users/1` вернёт *все* данные о пользователе (имя, возраст, адрес, список постов). Если мобильному клиенту нужно только имя, он получает *избыточные данные* (over-fetching).

В **GraphQL** клиент сам указывает, какие поля ему нужны.

  * **Запрос GraphQL:** `query { user(id: "1") { name } }`
  * **Ожидаемый результат (JSON):** `{"data": {"user": {"name": "John Doe"}}}`.
    Клиент получил *только* имя, избежав избыточности.

б) **Распознаватели (Resolvers):**
**Resolvers** — это *функции* на сервере GraphQL. Каждое поле в схеме GraphQL (в `Query`, `Mutation` или типе) привязано к своему распознавателю.
**Роль:** Роль распознавателя — *получить (вернуть) данные* для этого конкретного поля (сходить в БД, в кеш, или в другое API).
**Пример:** Для поля `user(id: ID)` в `Query` распознаватель может выглядеть так (JS):
`Query: {`
`   user: (parent, args) => { `
`     // args.id будет "1" `
`     return db.users.findById(args.id); `
`   } `
`}`

в) **gRPC в микросервисах:**
**gRPC** — это RPC (Remote Procedure Call) фреймворк от Google. Он часто используется для *внутреннего* высокопроизводительного взаимодействия между **микросервисами**.

**Отличия от GraphQL:**

1.  **Формат данных:** gRPC использует **Protocol Buffers** — эффективный *бинарный* формат для сериализации. GraphQL обычно использует **JSON** (текстовый).
2.  **Протокол:** gRPC работает поверх **HTTP/2**, что даёт ему мультиплексирование и стриминг. GraphQL обычно работает поверх HTTP/1.1 (хотя может и на HTTP/2).
3.  **Назначение:** GraphQL — это *язык запросов* (API Query Language), обычно для *внешних* клиентов (веб, мобайл). gRPC — это *RPC-фреймворк* для *внутренних* (server-to-server) коммуникаций, где важна максимальная производительность.